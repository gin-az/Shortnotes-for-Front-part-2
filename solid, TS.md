
### Дескрипторы ###
Основной метод для управления свойствами – Object.defineProperty.

Он позволяет объявить свойство объекта и, что самое главное, тонко настроить его особые аспекты, которые никак иначе не изменить.

Синтаксис:

```Object.defineProperty(obj, prop, descriptor)```

Аргументы:

__obj__ - Объект, в котором объявляется свойство.
__prop__ Имя свойства, которое нужно объявить или модифицировать.
descriptor
__Дескриптор__ – объект, который описывает поведение свойства.
В нём могут быть следующие поля:

`value` – значение свойства, по умолчанию undefined
`writable` – значение свойства можно менять, если true. По умолчанию false.
`configurable` – если true, то свойство можно удалять, а также менять его в дальнейшем при помощи новых вызовов defineProperty. По умолчанию false.
`enumerable` – если true, то свойство просматривается в цикле for..in и методе Object.keys(). По умолчанию false.
`get` – функция, которая возвращает значение свойства. По умолчанию undefined.
`set` – функция, которая записывает значение свойства. По умолчанию undefined.
Чтобы избежать конфликта, запрещено одновременно указывать значение value и функции get/set. Либо значение, либо функции для его чтения-записи, одно из двух. Также запрещено и не имеет смысла указывать writable при наличии get/set-функций.

`Object.freeze(obj)` - Запрещает добавлять/удалять/изменять свойства. Устанавливает configurable: false, writable: false для всех существующих свойств.

`Object.keys(obj)`, `Object.getOwnPropertyNames(obj)` возвращают массив – список свойств объекта.

Object.keys возвращает только enumerable-свойства.
Object.getOwnPropertyNames – возвращает все свойства

____
ts:
типы от интерфейсов (расширение extand, интерфейсы могут дублироваться)
в js остаются (enum)
is: 
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined
}
1 членом выражения является идентификатор, который обязан совпадать с идентификатором одного из параметров объявленных в сигнатуре функции.. Ко 2 члену выражения относится ключевое слово is, которое служит в качестве утверждения. В качестве 3 члена выражения может выступать любой тип данных.

Оператор ! (Non-Null and Non-Undefined Operator):  если разработчик в полной мере осознает последствия, то компилятор можно настоятельно попросить закрыть глаза на потенциально опасное место при помощи оператора Not-Null Not-Undefined. При обращении к полям и свойствам объекта, оператор Not-Null Not-Undefined указывается перед оператором точка object!.field.

 as: когда вы используете Typescript с JSX, возможно только приведение к типу через as.
let someValue: any = "this is a string";
 
let strLength: number = (someValue as string).length;

Расширенные типы TS(утилиты): https://senior.ua/articles/shpargalka-po-bazovyh-tipah-typescript

- Partial<T> позволяет сделать все свойства типа T необязательными. Он добавит ?отметку рядом с каждым полем.
- Required<T> утилита делает все свойства Tнужного типа обязательными.
- Readonly<T> Этот тип утилит преобразует все свойства типа T, чтобы сделать их не переназначаемыми с новым значением.
- Pick<T, K> Это позволяет вам создать новый тип из существующей модели T, выбрав некоторые свойства  K этого типа. Или несколько `|`.
- Omit<T, K> Утилита противоположность Pick типа. И вместо выбора элементов он удалит Kсвойства из типа T.
- Extract<T,U> позволяет вам создать тип, выбирая общие свойства, которые представлены в двух разных типах. Утилита извлечет из Tвсех свойств, которым можно присвоить U.
- Exclude<T,U> в отличие от этого Extract, утилита будет создавать тип, исключая свойства, которые уже присутствуют в двух разных типах. Он исключается из Tвсех полей, которым можно присвоить U.
- Record<K,T> Эта утилита помогает вам создать тип с набором свойств K данного типа T.
- NonNullable<T> Он позволяет снимать nullи undefinedс типа T.
- in Оператор позволяет проверить , существует ли свойство x в объекте, который получен в качестве параметра.





паттерн делегирования 
виртуализация списков, таблиц:

react-window — это библиотека, с помощью которой можно эффективно отображать большие списки, таблицы.

FixedSizeList для длинных одномерных списков с элементами одинакового размера.
VariableSizeList - компонент для отображения списков с элементами разного размера.
Для компонента FixedSizeGrid API практически такой же, но нужно указывать значения высоты, ширины и количества элементов как для столбцов, так и для строк.
Для компонента VariableSizeGrid можно изменять ширину столбцов и высоту строк, передавая функции, а не значения в соответствующие свойства этого компонента.

dry - Don’t repeat yourself (не повторяйся). Самый простой подход по уменьшению сложности — разделить систему на управляемые части. Каждая часть знания должна иметь единственное, непротиворечивое и авторитетное представление в рамках системы. Изменение единственного элемента системы не требует внесения изменений в другие, логически не связанные элементы. Те элементы, которые логически связаны, изменяются предсказуемо и единообразно.

kiss - keep it simple stupid (делайте вещи проще). Самое простое объяснение является самым правильным решением.
-не имеет смысла реализовывать дополнительные функции, которые не будут использоваться.
-не стоит подключать огромную библиотеку, если вам от неё нужна лишь пара - функций;
- не имеет смысла беспредельно увеличивать уровень абстракции, надо уметь вовремя остановиться;


solid:
S: Single Responsibility Principle (Принцип единственной ответственности) (Магическая кнопка - антипаттерн, каждый компонент отвечает за свою логику).
O: Open-Closed Principle (Принцип открытости-закрытости).
Код должен быть открыт для расширения, но закрыт для модификации. Пример API новое значение для свойства.
L: Liskov Substitution Principle (Принцип подстановки Барбары Лисков).
Функции, которые используют базовый тип, должны иметь возможность использовать подтипы базового типа, не зная об этом. (Родительский класс можно заменить дочерним.+-одинаковые методы.)
I: Interface Segregation Principle (Принцип разделения интерфейса).
'Клиенты' не должны реализовывать методы, интерфесы которые они не используют.
D: Dependency Inversion Principle (Принцип инверсии зависимостей). Модули и подмодули не должны зависить друг от друга, а должны зависеть от абстракций.

Фабрика - функция, которая возвращает разные реализации интерфейса на основе входных параметров.
Абстрактная фабрика - фабрика фабрик.
Фасад - реализацию процесса делим на функции(этапы). Для алгоритма определяем функцию в которой вызываются все функции этапов. Но мы также можем вызывать функции по отдельности для реализации части алгоритма, либо другого алгоритма.

